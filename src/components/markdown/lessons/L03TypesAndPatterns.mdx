# Lesson 3: Types and Patterns

You will recall from last lesson that memory safety requires that all memory
accessed

1.  Exists
2.  Contains valid data

In the previous lesson, we looked at how move semantics are used to ensure
memory is only accessed when it exists. In this lesson, we will look at how Rust
ensures that the memory contains valid data.

In Rust, all values have exactly one type. This type defines the space a value
will take up (which is needed to allocate that space for it in memory, typically
on the stack), and which possible memory values can occupy this space.

The Rust compiler is very good at inferring types from context for you. Often
you will only need to explicitly state your types in a function signature (as
here they are required so that you can build a stable API).

## Let Statements and Patterns

I've used this before in our previous lesson, but the way I used them will have
lulled you into a false sense of familiarity.

```rust
let pattern = expression; // type is inferred
let pattern: Type = expression; // type is explicit
```

You'll notice I say "pattern" and not variable name on the left. This is because
whenever new variables are introduced in Rust, it is not done through simple
variable declaration as you may be familiar with from other languages.

Patterns are very powerful, and allow you to do all kinds of powerful things
like destructuring and pattern matching. There will be more details on the
many different things you can do with patterns over the next few chapters.

For now, know that if you encounter an identifier in a pattern, which is
basically any valid variable name, it will create a new variable, allocate
memory for it based on the size of the type of the variable being created, and
bind all or some part of the value the expression on the right hand side of the
`=` evaluates to.

```rust
let x = 12; // creates `x` as an `i32`, binds 12 to `x`
let z = 'x'; // creates `z` as a `char`, binds 'x' to `x`
```

I'll teach you your first complex pattern already! The wildcard pattern. This
pattern matches any single value from the expression and ignores it.

```rust
let _ = "Hello, world!"; // creates no variable, binds nothing
```

This is useful if you have a function that returns data, but you wish to discard
the data without the compiler complaining at you for having an unused return
value.

Another pattern that is useful is the `mut identifier` pattern. By default, all
variables created are immutable and cannot be reassigned or mutated in place. By
using the `mut identifier` pattern you bypass this.

The following fails to compile.

```rust
let x = 12;
x = 9; // reassignment
x += 8; // mutation
println!("{number}");
```

```
error[E0384]: cannot assign twice to immutable variable `number`
 --> src/main.rs:3:5
  |
1 |     let number = 12;
  |         ------
  |         |
  |         first assignment to `number`
  |         help: consider making this binding mutable: `mut number`
2 |     number = 9; // reassignment
  |     ^^^^^^^^^^ cannot assign twice to immutable variable

error[E0384]: cannot assign twice to immutable variable `number`
 --> src/main.rs:4:5
  |
1 |     let number = 12;
  |         ------
  |         |
  |         first assignment to `number`
  |         help: consider making this binding mutable: `mut number`
2 |     number = 9; // reassignment
3 |     number += 8; // mutation
  |     ^^^^^^^^^^^ cannot assign twice to immutable variable
```

But by using `mut number` we can make the `number` variable mutable, and it will
compile and run successfully instead.

```rust
let mut number = 12;
number = 9;
number += 8;
println!("{number}");
```

```
17
```

Note that while you cannot reassign a variable, you can "shadow" it by using A
new `let` statement. This creates a new variable instead and gives it the name
the old one had.

```rust
let number = 12;
let number = 9;
println!("{number}");
```

```
9
```

## Fixed Size Primitive Types

Now that you know how to assign a variable, lets look at the simplest data types
a variable might have. These are the fixed size primitive types. They take up a
fixed amount of space, and have well defined restrictions on which values are
legal.

| Type    | Size | Values                                                                       |
| :------ | :--: | :--------------------------------------------------------------------------- |
| `!`     |  0   |                                                                              |
| `()`    |  0   | `()`                                                                         |
| `bool`  |  1   | `0x00` meaning `false`, and `0x01` meaning `true`                            |
| `u8`    |  1   | Natural numbers from $0$ to $2^{8}-1$ (unsigned 8 bit integers)              |
| `i8`    |  1   | Integers from $-(2^{7})$ to $2^{7}-1$ (signed 8 bit integers)                |
| `u16`   |  2   | Natural numbers from $0$ to $2^{16}-1$ (unsigned 16 bit integers)            |
| `i16`   |  2   | Integers from $-(2^{15})$ to $2^{15}-1$ (signed 16 bit integers)             |
| `u32`   |  4   | Natural numbers from $0$ to $2^{32}-1$ (unsigned 32 bit integers)            |
| `i32`   |  4   | Integers from $-(2^{31})$ to $2^{31}-1$ (signed 32 bit integers)             |
| `f32`   |  4   | IEEE 754-2008 binary32 format values (IEEE 754-1985 single precision floats) |
| `char`  |  4   | Any single [unicode scalar value][unicode].                                  |
| `u64`   |  8   | Natural numbers from $0$ to $2^{64}-1$ (unsigned 64 bit integers)            |
| `i64`   |  8   | Integers from $-(2^{63})$ to $2^{63}-1$ (signed 64 bit integers)             |
| `f64`   |  8   | IEEE 754-2008 binary64 format values (IEEE 754-1985 dounle precision floats) |
| `u128`  |  1   | Natural numbers from $0$ to $2^{128}-1$ (unsigned 128 bit integers)          |
| `i128`  |  1   | Integers from $-(2^{127})$ to $2^{127}-1$ (signed 128 bit integers)          |
| `usize` |  \*  | As per `u16`, `u32`, or `u64` depending on target platform's pointer type    |
| `isize` |  \*  | As per `i16`, `i32`, or `i64` depending on target platform's pointer type    |

_\*the `usize` and `isize` types have a platform specific size. For a 32 bit
computer they will be 4 bytes large, for a 64 bit computer they will be 8 bytes
large. 16 bit architectures are officially supported, but often require extra
work as most libraries do not support them._

If you want to tell Rust which numeric type to use for an integer or float
without using a let binding with explicit type, you can suffix the literal with
the type. With no suffix or typed binding integers will be `i32` and floats will
be `f32`.

```rust
let b: bool = true;
let n: u8 = 56;
let p = 81u8;
let s: i8 = -9;
let i = 93; // infers i32 by default
let f = 12.4; // infers f32 by default
let c = 'z';
```

You'll notice there are two fixed size primitive types that I've not included
in the above list, and that's because these will be less familiar to you unless
you are coming from a small handful of functional languages.

`()`, the "Unit" type, is a type with only one value: `()`. Because the type
only has one value, it needs 0 bytes of information to store this value.
Anywhere the unit type occurs, it's value is already known.

This type is seen most often as a kind of `void` return type. Indicating that a
function did not return any meaningful data, but did terminate normally and
return control to its caller. If you create a function with no explicit return
type then a type of `-> ()` is implicit. In addition, any expression terminated
with a `;` evaluates to `()`.

```rust
fn foo() -> () {
    println!("Function returns no data");
}
fn bar() {
    let x = ();
    println!("This also returns no data");
}
```

It is also possible to use a unit pattern to bind a unit value. This doesn't
seem very useful, and on its own it isn't and is equivalent to using a wildcard
binding, but you _can_ do it if you really want. There may be some niche case
in more advanced patterns where `()` is desirable over `_`, I'm not sure though.

```rust
// these lines are equivalent
let () = ();
let _ = ();
```

The final type in the above list is `!`, the "Never" type. It is a type with
zero values that cannot be constructed. Because of this, Rust can coerce it into
any other type. This is the type returned by control like `return`, `break`, and
`continue`, by functions like `std::process::exit` which get the operating
system to terminate the program, and by infinite loops or other similar non
returning structures.

Any code that falls after a variable with the Never type is initialised is
unreachable, because the compiler knows it's actually impossible to do that
initialisation.

```rust
// This `x` is an i32, because the loop breaks with a value of 12.
let x = loop {
    break 12;
};
// This `y` is a `!`, because the loop never terminates.
let y = loop { };
// All code after the above is unreachable, but this would also have the type `!`
let z = std::process::exit(0);
// Because they can't be constructed, it's fine to coerce a `!` type to anything
let a_number: i32 = z;
```

## Arrays

If you want to store multiple of the same type in sequence (directly adjacent)
in memory, you can use an array! Arrays have a fixed size known at compile time,
and their size will be the size of the type stored in the array, multiplied by
the number of elements in the array.

```rust
let a: [i32; 4] = [12, -8, 92, 3];
let b: [char; 3] = ['r', 'f', 'd'];
let c = [true, false, false, true, false]; // infers [bool; 5]
```

If you want to access the values in an array, you can index into it.

```rust
let a: [i32; 4] = [12, -8, 92, 3];
let p = a[0]; // p = 12
let q = a[1]; // q = -8
let r = a[2]; // r = 92
let s = a[3]; // s = 3
```

There is also a pattern we can use that allows us to destructure an array. This
is called a slice pattern.

```rust
let a: [i32; 4] = [12, -8, 92, 3];
let [p, q, r, s] = a; // slice pattern, p = 12, q = -8, r = 92, s = 3
```

Each of the identifiers inside the slice pattern is another pattern, which lets
you ignore some elements in an array using the wildcard pattern.

```rust
let b: [char; 3] = ['r', 'f', 'd'];
let [t, _, u] = b; // t = 'r', u = 'd'
```

There is also the "rest" pattern, which will match a sequence of zero or more
values that are not otherwise bound within the slice pattern.

```rust
let c = [true, false, false, true, false];
let [v, .., w] = c; // v = true, w = false
```

This is also a good time to introduce an extension to the identifier pattern. If
you use the form `identifier @ pattern`, then instead of binding a single value,
the value that matches the entier pattern will be bound to the identifier.
This is very useful with the rest pattern as it allows you to create a new array
from a subset of the source array.

```rust
let d = ['H', 'e', 'l', 'l', 'o'];
let [head, tail @ ..] = d; // head = 'H', tail = ['e', 'l', 'l', 'o']
let [mid @ .., _] = tail; // mid = ['e', 'l', 'l']
```

## Tuples

If you want to group together multiple different types into a single type, the
simplest way to do it is with a tuple! Like arrays, these must have a fixed
number of elements. Unlike arrays, each element has it's own type.

```rust
let a: (i32, char) = (12, 'C');
let b = (false, 12.5, ()); // infers type `(bool, f64, ())`
```

Values inside a tuple can be accessed using numeric field accessors.

```rust
let a = (12, 'C', false, 12.5);
let p = a.0; // p = 12
let q = a.1; // q = 'C'
let r = a.2; // r = false
let s = a.3; // s = 12.5
```

There is also a pattern that allows us to destructure a tuple, called a tuple
pattern!

```rust
let a = (12, 'C', false, 12.5);
let (p, q, r, s) = a; // p = 12, q = 'C', r = false, s = 12.5
```

As with arrays, this pattern allows us to use other patterns like rest and
wildcard inside of it.

```rust
let a = (12, 'C', false, 12.5);
let (head, ..) = a; // head = 12
let (.., penultimate, _) = a; // penultimate = false
```

Unlike with slices patterns however, you cannot use the `ident @ ..` syntax,
probably while arrays are sequential in memory and easy to copy, tuples can have
their fields re-ordered and padding inserted between them according to
arcane rules known as the ["default representation"][repr], meaning a trivial
"sub-tuple" is not guarunteed to exist in the way that a subsection of an array
is.

## References

## Structs

## Generic Types

## Generic Lifetimes

---

# Old Article Pending Rewrite (Stop Reading Here)

### Slices

It is also possible to have a sequence of unknown size (we call these unsized),
it is not possible for Rust to reserve space for these on the stack ahead of
time. We call such a sequence a slice and it is written `[T]`. The type `[u8]`
for example is a sequence of unsigned bytes of unkown (at compile time) length.

There is one other special unsized type: `str`. This type is equivalent to
`[u8]`, however the full sequence is guaranteed to be a valid UTF-8 encoded
string.

Because they are unsized, slices cannot be placed directly inside a variable,
as the compiler does not know how much space to reserve for that variable. In
order to store these in a variable we must use indirection, and so I must now
finally talk about references.

## Reference (and Pointer) Types

Last lesson I mentioned that Rust is trying to solve both memory safety _and_
thread safety. To achieve thread safety, values must only be accessed and
modified in a way that ensures all threads behave properly. To achieve this,
Rust disallows simultaneous mutable access.

To further motivate references, consider the undesirable effect of move
semantics, that no value of a type with move semantics could be passed to a
function without either being explicitly dropped when the function ends, or
manually returned to the caller to hand back ownership.

Consider further that there would be no way for a function to modify a value
in place, regardless of if the value has move or copy semantics.

References provide indirection and are the solution to all of these issues, but
in order to ensure thread safety Rust has two reference types instead of one.

The first, `&T`, is called a reference and provides read only access. Many of
these references may coexist. Because multiple of these references to the same
value can exist, `&T` has copy semantics regardless of the semantics of `T`.
If a reference to a value exists, we say that the reference borrows the value.

The second, `&mut T`, is called a mutable reference and provides read and write
access. Only one such mutable reference to a value may exist at a time. A
mutable reference cannot coexist with an immutable reference. `&mut T` always
has move semantics (moving the reference, not the value). If a mutable reference
to a value exists, we say the mutable reference borrows the value as mutable.

You can create a reference of any value so long as that value is not borrowed as
mutable. You can create a mutable reference of any value so long as that value
is not borrowed.

A reference cannot outlive the value it borrows as this would allow a use after
free memory error, thus a value cannot be dropped while a reference to it
exists.

Because of the restrictions that references place on a value (dropping, creation
of mutable references), we say all references have a lifetime. This lifetime is
the duration for which those restrictions are applied. In some circumstances
lifetimes can be named, a lifetime named `lt` is written `&'lt ___` or
`&'lt mut ___`. One special named lifetime exists by default: `'static`.
References with this lifetime are held for the entire duration of the program
(and thus the value they point to is never dropped).

There are two possible sizes a reference can have, depending on the type of the
borrowed value. If the borrowed value is a sized type, references to it will
have the same size as `usize`, storing a pointer to the value in memory.

If the borrowed value is an unsized type, references to it will have twice the
size of `usize`, with half storing a pointer to the value in memory, and the
other half storing the size of the value. This ability for references to borrow
unsized types with a known size solves the problem from the previous section,
we cannot store a `str` or slice `[T]` directly in a variable, but we can store
a reference to them!

```rust
fn main() {
    let x: [i32; 6] = [1, 4, 65, -110, 75, 93];
    println!("How many numbers would you like? [1 to 6]");
    let y: usize = read_number();
    let z: &[i32] = &x[0..y]; // unsized slice in a variable!
    println!("Here are your numbers: {z:?}");
}

/// Function included only to make this example work,
/// please don't worry about what it's doing!
fn read_number() -> usize {
    let mut buf = String::new();
    std::io::stdin().read_line(&mut buf).unwrap();
    buf.trim().parse().unwrap()
}
```

This should help explain the string literals from our last lesson. A string
literal creates a value of the type `&'static str`. `str` because it is a valid
UTF-8 unicode string, `&'static` because the string value is written into the
binary and never dropped. Because these are an immutable reference they have
copy semantics as you saw.

Pointers, usually called "raw pointers" in Rust, exist both for interoperability
with C and to allow implementing custom types that perform their own memory
management (the standard library has many of these). These types are `*const T`
and `*mut T`. They do not have lifetimes, and do not enforce thr same
restrictions as their reference counterparts. They are easy to create from
references, but cannot be read from, written to, or converted back into
references without using the `unsafe` keyword and promising Rust that you have
upheld its memory and thread safety guarantees despite them not being enforced.

## Slices Again, and Range Syntax

Now that you know about pointers, lets circle back around to slices. They are
typically created using range syntax `a..b` and an array or similarly indexable
data structure. Ranges are a data structure in their own right (actually 6) and
are one of the worst designed things in Rust. Everybody hates them and agrees we
designed them badly. Somehow they snuck into Rust 1.0 and now we're stuck with
them for backwards compatability reasons. There are 6 ways to create a Range, 6
types that will be created, and far too little interoperability between them.

```rust
let a: std::ops::Range = 5..12; // 5 ≤ x < 12
let b: std::ops::RangeFrom = 9..; // 9 ≤ x
let c: std::ops::RangeTo = ..6; // x < 6
let d: std::ops::RangeFull = ..; // completely unbounded
let e: std::ops::RangeInclusive = 8..=16; // 8 ≤ x ≤ 16
let f: std::ops::RangeToInclusive = ..=14; // x ≤ 14
```

Ranges can be used in a few places, but the only place you will see all 6 of the
above used is in creating slices. In this context, they are used as an index to
an array, a slice, or another similar data structure (such as a `Vec`, which
we'll cover in a future lesson).

```rust
let x: [i32; 6] = [1, 4, 65, -110, 75, 93];
let y: &[i32] = &x[..]; // slice the whole of x
let z: &[i32] = &y[1..=3]; // slice the elements with indexes in the range 1 ≤ x ≤ 3
```

Slices can also be broken down using slice patterns, but you must include the
rest pattern `..` for the pattern to be irrefutable (again, we'll get to
refutable patterns eventually) because you cannot know its length.

```rust
let x: [i32; 6] = [1, 4, 65, -110, 75, 93];
let y: &[i32] = &x[..];
let [head, tail @ ..] = y; // head = 1, tail = &[4, 65, -110, 75, 93]
```

## Functional Types

When you create a function you also create a unit type representing that
function, which has a value identified by the function name. This unit value
can be assigned to a variable and called the same as one might call the
function, but the type cannot be named and must only be inferred.

```rust
fn main() {
    let my_fn = add_one;
    println!("{}", my_fn(4))
}

fn add_one(x: i32) -> i32 {
    x + 1
}
```

If you do want to prescribe a type, you can coerce a function unit value into a
function pointer. This has size equivalent to `usize` instead of having zero
size like the function unit value, and it's value is the memory address where
the function is stored. Function pointer types are written `fn(params) -> ret`.

```rust
fn main() {
    let my_fn: fn(i32) -> i32 = add_one;
    println!("{}", my_fn(4))
}

fn add_one(x: i32) -> i32 {
    x + 1
}
```

## User Defined Types

There are three kinds of user defined types: structs, enums, and unions.
Structs and enums are extremely useful. Unions exist mostly for C interop.

### Structs

There are three types of struct definition: unit structs, tuple structs, and
named field structs.

The first of the three allows custom user defined unit types. These are useful
for representing trivial state with custom implementations (more on this next
lesson).

```rust
struct MyUnitStruct;

fn main() {
    let x = MyUnitStruct;
}
```

The second of the three allows custom tuple structs, which behave like tuples
with numeric index keys and destructuring, but act as an independent type with
their own implementations.

```rust
struct MyTupleStruct(i32, char);

let x = MyTupleStruct(-16, 'L');
let a = x.0; // a == -16
let b = x.1; // b == 'L'
```

And a new pattern for destructuring it, which works exactly like the tuple
pattern but for tuple structs.

- The tuple struct pattern `TupleStruct(comma_separated_patterns)` matches
  tuple struct values and destructures them.

```rust
let MyTupleStruct(a, b) = x; // a == -16, b == 'L'
```

The final of the three, and most commonly seen, is a named field struct. It has
no equivalent primitives type, but you can think of it as a tuple with named
fields.

```rust
struct MyFieldStruct {
    my_number: i32,
    my_letter: char,
}

let x = MyFieldStruct {
    my_number: 24,
    my_letter: 'K',
};
let a = x.my_number; // a == 24
let b = x.my_letter; // b == 'K'
```

And another new pattern for destructuring it:

- The struct pattern `Struct { field: pattern, .. }` matches named field struct
  values and destructures them.

You can also use a dirty syntax hack that is designed to look like the rest
pattern but isn't actually a pattern (because you can't use the `ident @ ..`
pattern with it).

```rust
let MyFieldStruct {
    my_number: a,
    my_letter: b
} = x; // a == 24, b == 'K'
```

### Unions

In almost a decade of writing and using Rust code I have never needed a union.
If you do need them, then you're either doing C interop and already know what
you are doing, or you're wrong and should use another data structure instead.

Almost always that data structure is enums. Or it's `std::mem::transmute`.

### Enums

Enums in Rust are not like in most other languages. They can be, as you will
see, but typically they are used in a way that is significantly more poweful.

There are three types of enum in Rust: C-like enums, sum type enums, and
zero-variant enums.

C-like enums work like the enums in most languages, providing an association
between a number and a named value.

```rust
enum CLikeEnum {
    ImplicitZero, // Defaults to `= 0`
    First, // Continues as `= 1`
    Second = 2, // Explicit number
    Tenth = 10, // Can skip ahead
}

fn main() {
    let e = CLikeEnum::Second;
    let n = e as i32;
}
```

Sum type enums allow you to define a type that has multiple possible mutually
exclusive states called variants. Variants, like structs, can be unit, tuple, or
named field variants.

```rust
enum SumTypeEnum {
    MyUnitVariant,
    MyTupleVariant(i32, char),
    MyNamedFieldVariant {
        my_str: &'static str,
        my_bool: bool,
    }
}

fn main() {
    let mut a: SumTypeEnum = SumTypeEnum::MyUnitVariant;
    a = SumTypeEnum::MyTupleVariant(-8, 'g');
    a = SumTypeEnum::MyNamedFieldVariant {
        my_str: "Example!",
        my_bool: true,
    };
}
```

There are also patterns that can destructure enums, but we are going to have to
talk about refutable patterns finally. Actually, technically you can use
irrefutable patterns to destructure an enum, but you have a strict condition and
a new pattern:

- Or patterns `pattern_a | pattern_b` can match either pattern. Both patterns
  must produce identical variables (in name and type).

Because of the restriction that both sides must produce the same variable in
name and type, you are quite restricted in how you can use this with enums, but
you could do the following:

```rust
enum Silly {
    HasANumber(i32, char),
    AlsoHasANumber {
        num: i32,
        float: f32,
    }
}

let x = Silly::HasANumber(12, 'c');
let (Silly::HasANumber(n, _) | Silly::AlsoHasANumber { num: n, .. }) = x;
```

Struct syntax also has a convenience to make your life easier. If you want to
bind a variable with the same name as a field, instead of doing

```rust
let Struct { field: field } = Struct { field: 12 };
```

You can instead ommit the `: field`.

```rust
let Struct { field } = Struct { field: 12 };
```

## Refutable Patterns

So far, I've only shown you irrefutable patterns. This means that the pattern
can always bind to a value provided the value is of the correct type. It is also
possible to construct patterns where the value _might_ be able to match, but it
also might not. A trivial example of this introduces a new pattern:

- Range patterns `start..end` match scalar values within their defined bounds.

```rust
let x = 8;
let bigger_than_four @ 4.. = x;
```

```text
error[E0005]: refutable pattern in local binding
 --> src/main.rs:3:9
  |
2 |     let bigger_than_four @ 4.. = x;
  |         ^^^^^^^^^^^^^^^^ pattern `i32::MIN..=3_i32` not covered
```

Ah fun, a compiler error. You can see the error is quite elegantly explaiend
though. Even though we know that our `x` in this instance is bigger than 4, the
compiler has no guaruntees that `x` is bigger than four, and so there is no
coverage of the case where `x` is between the smallest possible `i32`, and 3.

There are two new syntax elements we can use to resolve this.

### If Let Expressions

An if let statement has the following form:

```rust
if let refutable_pattern = expression {
    /* block contents */
} else {
    /* block contents */
}
```

The else block is optional.

This allows us to do the following:

```rust
let x = 8;
if let 4.. = x {
    println!("The number {x} was equal to or bigger than four!");
} else {
    println!("The number {x} was smaller than four");
}
```

Obviously this is a contrived example, and you shouldn't actually do that, you
would just do `if x >= 4 {}` in real code, but you _can_ do it with pattern
matching instead if you want to make your colleagues hate you.

A more useful example of this syntax comes from using struct and tuple struct
patterns to break down a refutable enum.

```rust
enum IntOrFloat {
    Num(i32),
    Float {
        f: f32,
    }
}

let x = IntOrFloat::Num(12);

if let IntOrFloat::Float { f } = x {
    println!("We have a float: {f}!");
} else if let IntOrFloat::Num(n) = x {
    println!("We have an integer: {n}!");
}
```

Also note that If Lets are expressions and not statements, this means you can
use them in an expression position, and they will evaluate to the last
expression in the appropriate block.

```rust
let my_float = if let IntOrFloat::Float { f } = x {
    println!("We have a float: {f}!");
    f
} else if let IntOrFloat::Num(n) = x {
    return Error(format!("We have an integer: {n}! That's bad!"));
};
```

### Let Else Statements

Sometimes, you are fairly confident the refutable pattern will be a certain
form, or you otherwise simply want to return an error if a value does not match
the pattern you expect it to. In this instance you can use a let else statement.

```rust
let refutable_pattern = expression else {
    /* block */
}
```

This makes writing the above error handling with our float much simpler! Though
we do lose the ability to use else if and destructure the alternative case.

```rust
let IntOrFloat::Float { f } = x else {
    return Error(format!("We have an integer, That's bad!"));
}
println!("We have a float: {f}!");
```

### Match Expressions

Match expressions are great when you want to handle all the possible cases, and
are a lot less cumbersome than using if let else if let for the equivalent,
especially when you have many possible cases to provide a pattern for.

```rust
match expression {
    pattern_a => expression_a,
    patterb_b => expression_b,
    ...
}
```

For example, replicating our expression from earlier.

```rust
let my_float = match x {
    IntOrFloat::Float { f } => {
        println!("We have a float: {f}!");
        f
    },
    IntOrFloat::Num(n) => {
        return Error(format!("We have an integer: {n}! That's bad!"));
    }
};
```

## Generics

User defined types can have generic type parameters. These allow for types
inside the UDT to be defined by the user of the UDT, rather than by the UDT
itself.

```rust
struct MyDataStruct<T> {
    my_num: i32,
    my_data: T,
}
enum Choice<A, B> {
    First(A),
    Second(B),
    Neither,
    Both {
        first: A,
        second: B
    }
}
fn main() {
    let x: MyDataStruct<char> = MyDataStruct {
        my_num: 17,
        my_data: 'G',
    };
    let y: Choice<f64, MyDataStruct<char>> = Choice::Second(x);
}
```

In the above, `Choice<f64, MyDataStruct<char>>` essentially creates the
following type:

```rust
struct MyDataStruct<char> {
    my_num: i32,
    my_data: char,
}
enum Choice<f64, MyDataStruct<char>> {
    First(f64),
    Second(MyDataStruct<char>),
    Neither,
    Both {
        first: f64,
        second: MyDataStruct<char>,
    }
}
```

User defined types can also have generic lifetimes. This allows them to store
references.

```rust
struct HoldsAReference<'a> {
    ref_to_number: &'a i32,
}
```

If the number is static, you will have a `HoldsAReference<'static>`. If it has
some other lifetime (which are almost always anonymous), then you will have a
`HoldsAReference<'some_unnamed_anonymous_lifetime>`.

[repr]: https://doc.rust-lang.org/reference/type-layout.html#the-default-representation
[unicode]: https://www.unicode.org/glossary/#unicode_scalar_value
