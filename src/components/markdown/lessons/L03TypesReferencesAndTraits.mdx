# Lesson 3: Types, References, and Traits

You will recall from last lesson that memory safety requires that all memory
accessed

 1. Exists
 2. Contains valid data 

In the previous lesson, we looked at how move semantics are used to ensure
memory is only accessed when it exists. In this lesson, we will look at how Rust
ensures that the memory contains valid data.

In Rust, all values have exactly one type. This type defines the space a value
will take up (which is needed to allocate that space for it in memory, typically
on the stack), and which possible memory values can occupy this space.

## Fixed Size Primitive Types

The following is a summary of Rusts fixed size primitive types, their size in
bytes, and their legal values.

| Type | Size | Values |
| :--- | :--: | :----- |
| `!`    | 0    |        |
| `()`   | 0    | `()` |
| `bool` | 1    | `true` as `0x01`, `false` as `0x00` |
| `u8`   | 1 | Natural numbers from $0$ to $2^{8}-1$ |
| `i8` | 1 | Integers from $-(2^{7})$ to $2^{7}-1$ |
| `u16` | 2 | Natural numbers from $0$ to $2^{16}-1$ |
| `i16` | 2 | Integers from $-(2^{15})$ to $2^{15}-1$ |
| `u32` | 4 | Natural numbers from $0$ to $2^{32}-1$ |
| `i32` | 4 | Integers from $-(2^{31})$ to $2^{31}-1$ |
| `f32` | 4 | All IEEE 754-2008 binary32 format values (754-1985 single precision float) |
| `char` | 4 | Any unicode scalar value in the `0x0000` to `0xD7FF` or `0xE000` to `0x10FFFF` range |
| `u64` | 8 | Natural numbers from $0$ to $2^{64}-1$ |
| `i64` | 8 | Integers from $-(2^{63})$ to $2^{63}-1$ |
| `f32` | 8 | All IEEE 754-2008 binary64 format values (754-1985 dounle precision float) |
| `u128` | 1 | Natural numbers from $0$ to $2^{128}-1$ |
| `i128` | 1 | Integers from $-(2^{127})$ to $2^{127}-1$ |
| `usize` | * | As per `u16`, `u32`, or `u64` depending on target platform's pointer type|
| `isize` | * | As per `i16`, `i32`, or `i64` depending on target platform's pointer type|

*\*the `usize` and `isize` types have a platform specific size. For a 32 bit
computer they will be 4 bytes large, for a 64 bit computer they will be 8 bytes
large*

Two types above seem more odd, and not as self explanatory as the others. These
are the two with zero size. `()` is pronounced "unit" and is a type with only
one value, also called `()` "unit". This type takes up no space, as anywhere the
compiler encounters this type it can work with it without needing to store any
value (as it knows the value without storing it).

The most common place you will encounter `()` is as the return type from
functions and expressions that return no data. It is similar to `void` in other
languages.

The other type, `!`, is pronounced "never", and it cannot be constructed.
Anywhere the compiler encounters a value of this type it can assume is
unreachable code, as no value of this type exists.

The most common place you will encounter `!` is as the return type from
functions that loop infinitely and never terminate or where execution branches.

All the other types can be constructed and represented in code simply as their
numeric representation, or a character in single quotes for the `char` type.
Rust will infer the correct type if not explicitly given, though it can be
suffixed to the numeric value, or any type can be prescribed in the `let`
expression after the variable name (`let variable: type = value;`).

```rust
let u = (); // `u: ()` is inferred
let b: bool = true;
let n: u8 = 56;
let p = 81u8;
let s: i8 = -9;
let i = 93; // infers i32 by default 
let f = 12.4; // infers f32 by default
let c = 'z'; // infers char from `'`
let never = loop { }; // loops forever, `never` is never assigned to
```

## Sequence Types

In addition to the above fixed size primitive types, Rust provided us with some
sequence types.

Arrays allow you to store a fixed size sequence of a type adjacent to each other
in memory. We denote this `[T; N]`, such that `[i32; 4]` takes up 16 bytes of
memory. You can access the parts of an array through numeric indices
starting at 0. You can also destructure arrays, which I'll show here but we'll
talk more about those more next lesson.

```rust
let x = [122, -68, 70, 32]; // infers `x: [i32; 4]`
let a = x[0]; // a == 122
let b = x[1]; // b == -68
let c = x[2]; // c == 70
let d = x[3]; // d == 32
let [p, q, r, s] = x; // p == 122, q == -68, r == 70, s == 32
```

Tuples allow you to store a sequence of different types in memory, though Rust
may place padding between them or change their in memory order according to
arcane rules known as the ["default representation"][repr]. `(i32, char)` is a
sequence of a 32-bit integer and a unicode scalar character (UTF-32). You can
access the parts of a tuple through numeric field access starting at 0. You can
also destructure tuples, but again more on that next lesson.

```rust
let x = (2503, 'B'); // infers `x: (i32, char)`
let a = x.0; // a == 2503
let b = x.1; // b == 'B'
let (p, q) = x; // p == 2503, q == 'B'
```

It is also possible to have a sequence of unknown size (we call these unsized), 
it is not possible for Rust to reserve space for these on the stack ahead of
time. We call such a sequence a slice and it is written `[T]`. The type `[u8]`
for example is a sequence of unsigned bytes of uknown (at compile time) length.

There is one other special unsized type: `str`. This type is equivalent to
`[u8]`, however the full sequence is guaranteed to be a valid UTF-8 encoded
string.

Because they are unsized, slices cannot be placed directly inside a variable,
as the compiler does not know how much space to reserve for that variable. In 
order to store these in a variable we must use indirection, and so I must now
finally talk about references.

## Reference (and Pointer) Types

Last lesson I mentioned that Rust is trying to solve both memory safety *and* 
thread safety. To achieve thread safety, values must only be accessed and
modified in a way that ensures all threads behave properly. To achieve this,
Rust disallows simultaneous mutable access.

To further motivate references, consider the undesirable effect of move 
semantics, that no value of a type with move semantics could be passed to a
function without either being explicitly dropped when the function ends, or 
manually returned to the caller to hand back ownership.

Consider further that there would be no way for a function to modify a value
in place, regardless of if the value has move or copy semantics.

References provide indirection and are the solution to all of these issues, but
in order to ensure thread safety Rust has two reference types instead of one.

The first, `&T`, is called a reference and provides read only access. Many of
these references may coexist. Because multiple of these references to the same
value can exist, `&T` has copy semantics regardless of the semantics of `T`.
If a reference to a value exists, we say that the reference borrows the value.

The second, `&mut T`, is called a mutable reference and provides read and write
access. Only one such mutable reference to a value may exist at a time. A
mutable reference cannot coexist with an immutable reference. `&mut T` always
has move semantics (moving the reference, not the value). If a mutable reference
to a value exists, we say the mutable reference borrows the value as mutable.

You can create a reference of any value so long as that value is not borrowed as
mutable. You can create a mutable reference of any value so long as that value
is not borrowed.

A reference cannot outlive the value it borrows as this would allow a use after
free memory error, thus a value cannot be dropped while a reference to it
exists.

Because of the restrictions that references place on a value (dropping, creation
of mutable references), we say all references have a lifetime. This lifetime is
the duration for which those restrictions are applied. In some circumstances
lifetimes can be named, a lifetime named `lt` is written `&'lt ___` or
`&'lt mut ___`. One special named lifetime exists by default: `'static`.
References with this lifetime are held for the entire duration of the program
(and thus the value they point to is never dropped).

There are two possible sizes a reference can have, depending on the type of the
borrowed value. If the borrowed value is a sized type, references to it will
have the same size as `usize`, storing a pointer to the value in memory.

If the borrowed value is an unsized type, referencez to it will have twice the
size of `usize`, with half storing a pointer to the value in memory, and the
other half storing the size of the slice. This ability for references to borrow
unsized types with a known size solves the problem from the previous section,
we cannot store a `str` or slice `[T]` directly in a variable, but we can store
a reference to them!

```rust
fn main() {
    let x: [i32; 4] = [1, 4, 65, -110];
    println!("How many numbers would you like? [1 to 4]");
    let y: usize = read_number();
    let z: &[i32] = &x[0..y]; // unsized slice in a variable!
    println!("Here are your numbers: {z:?}");
}

/// Function included only to make this example work,
/// please don't worry about what it's doing!
fn read_number() -> usize {
    let mut buf = String::new();
    std::io::stdin().read_line(&mut buf).unwrap();
    buf.trim().parse().unwrap()
}
```

This should help explain the string literals from our last lesson. A string
literal creates a value of the type `&'static str`. `str` because it is a valid
UTF-8 unicode string, `&'static` because the string value is written into the
binary and never dropped. Because these are an immutable reference they have
copy semantics as you saw.

## Functional Types

**todo**

## User Defined Types

**todo**

## Traits

**todo**

[repr]: https://doc.rust-lang.org/reference/type-layout.html#the-default-representation